---
title: Tudo o que você queria saber sobre exceções
description: O tratamento de erro é apenas uma parte da vida quando se trata de escrever código.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: 589e5d1decff7aa49ce36e10908e4464a768758d
ms.sourcegitcommit: 1dfd5554b70c7e8f4e3df19e29c384a9c0a4b227
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/03/2021
ms.locfileid: "101685515"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="3e72c-103">Tudo o que você queria saber sobre exceções</span><span class="sxs-lookup"><span data-stu-id="3e72c-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="3e72c-104">O tratamento de erro é apenas uma parte da vida quando se trata de escrever código.</span><span class="sxs-lookup"><span data-stu-id="3e72c-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="3e72c-105">Geralmente, podemos verificar e validar condições para um comportamento esperado.</span><span class="sxs-lookup"><span data-stu-id="3e72c-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="3e72c-106">Quando o erro é inesperado, recorreremos à manipulação de exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="3e72c-107">Você pode facilmente manipular exceções geradas pelo código de outras pessoas ou pode gerar as suas próprias exceções para que outras pessoas as manipulem.</span><span class="sxs-lookup"><span data-stu-id="3e72c-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="3e72c-108">A [versão original][] deste artigo foi publicada no blog escrito por [@KevinMarquette][].</span><span class="sxs-lookup"><span data-stu-id="3e72c-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="3e72c-109">A equipe do PowerShell agradece a Kevin por compartilhar o conteúdo conosco.</span><span class="sxs-lookup"><span data-stu-id="3e72c-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="3e72c-110">Confira o blog dele em [PowerShellExplained.com][].</span><span class="sxs-lookup"><span data-stu-id="3e72c-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="3e72c-111">Terminologia básica</span><span class="sxs-lookup"><span data-stu-id="3e72c-111">Basic terminology</span></span>

<span data-ttu-id="3e72c-112">Precisamos abordar alguns termos básicos antes de continuarmos.</span><span class="sxs-lookup"><span data-stu-id="3e72c-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="3e72c-113">Exceção</span><span class="sxs-lookup"><span data-stu-id="3e72c-113">Exception</span></span>

<span data-ttu-id="3e72c-114">Uma Exceção é como um evento que é criado quando o tratamento de erro normal não pode lidar com o problema.</span><span class="sxs-lookup"><span data-stu-id="3e72c-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="3e72c-115">Tentar dividir um número por zero ou ficar sem memória são exemplos de algo que cria uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="3e72c-116">Às vezes, o autor do código que você está usando cria exceções para determinados problemas quando eles acontecem.</span><span class="sxs-lookup"><span data-stu-id="3e72c-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="3e72c-117">Gerar e capturar</span><span class="sxs-lookup"><span data-stu-id="3e72c-117">Throw and Catch</span></span>

<span data-ttu-id="3e72c-118">Quando ocorre uma exceção, dizemos que uma exceção é gerada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="3e72c-119">Para manipular uma exceção gerada, você precisa capturá-la.</span><span class="sxs-lookup"><span data-stu-id="3e72c-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="3e72c-120">Se uma exceção for gerada e não for capturada por algo, o script parará de ser executado.</span><span class="sxs-lookup"><span data-stu-id="3e72c-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="3e72c-121">A pilha de chamadas</span><span class="sxs-lookup"><span data-stu-id="3e72c-121">The call stack</span></span>

<span data-ttu-id="3e72c-122">A pilha de chamadas é a lista de funções que chamaram umas às outras.</span><span class="sxs-lookup"><span data-stu-id="3e72c-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="3e72c-123">Quando uma função é chamada, ela é adicionada à pilha ou ao começo da lista.</span><span class="sxs-lookup"><span data-stu-id="3e72c-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="3e72c-124">Quando a função sai ou retorna, ela é removida da pilha.</span><span class="sxs-lookup"><span data-stu-id="3e72c-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="3e72c-125">Quando uma exceção é gerada, essa pilha de chamadas é verificada para que um manipulador de exceção a capture.</span><span class="sxs-lookup"><span data-stu-id="3e72c-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="3e72c-126">Erros de encerramento e de não encerramento</span><span class="sxs-lookup"><span data-stu-id="3e72c-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="3e72c-127">Uma exceção é geralmente um erro de encerramento.</span><span class="sxs-lookup"><span data-stu-id="3e72c-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="3e72c-128">Uma exceção gerada é capturada ou termina a execução atual.</span><span class="sxs-lookup"><span data-stu-id="3e72c-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="3e72c-129">Por padrão, um erro de não encerramento é gerado pelo `Write-Error` e ele adiciona um erro ao fluxo de saída sem gerar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="3e72c-130">Ressaltei isso porque `Write-Error` e outros erros de não encerramento não disparam o `catch`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="3e72c-131">Assimilando uma exceção</span><span class="sxs-lookup"><span data-stu-id="3e72c-131">Swallowing an exception</span></span>

<span data-ttu-id="3e72c-132">Isso ocorre quando você captura um erro apenas para suprimi-lo.</span><span class="sxs-lookup"><span data-stu-id="3e72c-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="3e72c-133">Faça isso com cautela porque pode dificultar bastante a solução de problemas.</span><span class="sxs-lookup"><span data-stu-id="3e72c-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="3e72c-134">Sintaxe de comando básica</span><span class="sxs-lookup"><span data-stu-id="3e72c-134">Basic command syntax</span></span>

<span data-ttu-id="3e72c-135">A seguir está uma rápida visão geral da sintaxe básica de manipulação de exceção usada no PowerShell.</span><span class="sxs-lookup"><span data-stu-id="3e72c-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="3e72c-136">Throw</span><span class="sxs-lookup"><span data-stu-id="3e72c-136">Throw</span></span>

<span data-ttu-id="3e72c-137">Para criar o nosso próprio evento de exceção, geramos uma exceção com a palavra-chave `throw`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="3e72c-138">Isso cria uma exceção de runtime que é um erro de encerramento.</span><span class="sxs-lookup"><span data-stu-id="3e72c-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="3e72c-139">Ele é manipulado por um `catch` em uma função de chamada ou sai do script com uma mensagem como esta.</span><span class="sxs-lookup"><span data-stu-id="3e72c-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="3e72c-140">Write-Error -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="3e72c-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="3e72c-141">Mencionei que o `Write-Error` não gera um erro de encerramento por padrão.</span><span class="sxs-lookup"><span data-stu-id="3e72c-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="3e72c-142">Se você especificar `-ErrorAction Stop`, `Write-Error` gerará um erro de encerramento que pode ser manipulado com um `catch`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-142">If you specify `-ErrorAction Stop`, `Write-Error` generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="3e72c-143">Agradecemos a Lee Dailey por nos lembrar de usar o `-ErrorAction Stop` dessa maneira.</span><span class="sxs-lookup"><span data-stu-id="3e72c-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="3e72c-144">Cmdlet -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="3e72c-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="3e72c-145">Se você especificar `-ErrorAction Stop` em qualquer função ou cmdlet avançado, ele transformará todas as instruções `Write-Error` em erros de encerramento que interromperão a execução ou que poderão ser manipulados por um `catch`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="3e72c-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="3e72c-146">Try/Catch</span></span>

<span data-ttu-id="3e72c-147">A maneira como a manipulação de exceção funciona no PowerShell (e em muitas outras linguagens) é que você primeiro realiza `try` em uma seção de código e, se ele gerar um erro, você poderá realizar `catch` nela.</span><span class="sxs-lookup"><span data-stu-id="3e72c-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="3e72c-148">Aqui está um exemplo rápido.</span><span class="sxs-lookup"><span data-stu-id="3e72c-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="3e72c-149">O script `catch` só será executado se houver um erro de encerramento.</span><span class="sxs-lookup"><span data-stu-id="3e72c-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="3e72c-150">Se o `try` for executado corretamente, ele ignorará o `catch`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="3e72c-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="3e72c-151">Try/Finally</span></span>

<span data-ttu-id="3e72c-152">Às vezes, você não precisa tratar um erro, mas ainda precisa que algum código seja executado se uma exceção ocorrer ou não.</span><span class="sxs-lookup"><span data-stu-id="3e72c-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="3e72c-153">Um script `finally` faz exatamente isso.</span><span class="sxs-lookup"><span data-stu-id="3e72c-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="3e72c-154">Veja este exemplo:</span><span class="sxs-lookup"><span data-stu-id="3e72c-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="3e72c-155">Sempre que você abrir ou se conectar a um recurso, deverá fechá-lo.</span><span class="sxs-lookup"><span data-stu-id="3e72c-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="3e72c-156">Se o `ExecuteNonQuery()` gera uma exceção, a conexão não é fechada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="3e72c-157">A seguir está o mesmo código dentro de um bloco `try/finally`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="3e72c-158">Nesse exemplo, a conexão será encerrada se houver um erro.</span><span class="sxs-lookup"><span data-stu-id="3e72c-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="3e72c-159">Ela também será encerrada se não houver erro.</span><span class="sxs-lookup"><span data-stu-id="3e72c-159">It also is closed if there's no error.</span></span> <span data-ttu-id="3e72c-160">O script `finally` é executado todas as vezes.</span><span class="sxs-lookup"><span data-stu-id="3e72c-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="3e72c-161">Como você não está capturando a exceção, ela ainda será propagada na pilha de chamadas.</span><span class="sxs-lookup"><span data-stu-id="3e72c-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="3e72c-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="3e72c-162">Try/Catch/Finally</span></span>

<span data-ttu-id="3e72c-163">É perfeitamente válido usar `catch` e `finally` juntos.</span><span class="sxs-lookup"><span data-stu-id="3e72c-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="3e72c-164">Na maioria das vezes, você usará um ou outro, mas poderá encontrar cenários em que usa ambos.</span><span class="sxs-lookup"><span data-stu-id="3e72c-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="3e72c-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="3e72c-165">$PSItem</span></span>

<span data-ttu-id="3e72c-166">Agora que explicamos as noções básicas, podemos nos aprofundar um pouco mais.</span><span class="sxs-lookup"><span data-stu-id="3e72c-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="3e72c-167">Dentro do bloco `catch`, há uma variável automática (`$PSItem` ou `$_`) do tipo `ErrorRecord` que contém os detalhes sobre a exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="3e72c-168">A seguir está uma visão geral rápida de algumas das principais propriedades.</span><span class="sxs-lookup"><span data-stu-id="3e72c-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="3e72c-169">Nesses exemplos, usei um caminho inválido em `ReadAllText` para gerar a exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="3e72c-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="3e72c-170">PSItem.ToString()</span></span>

<span data-ttu-id="3e72c-171">Isso lhe fornece a mensagem mais limpa a ser usada no registro em log e na saída geral.</span><span class="sxs-lookup"><span data-stu-id="3e72c-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="3e72c-172">`ToString()` será chamado automaticamente se `$PSItem` for colocado em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3e72c-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="3e72c-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="3e72c-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="3e72c-174">Essa propriedade contém informações adicionais coletadas pelo PowerShell sobre a função ou o script no qual a exceção foi gerada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="3e72c-175">A seguir está o `InvocationInfo` da exceção de exemplo que criei.</span><span class="sxs-lookup"><span data-stu-id="3e72c-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="3e72c-176">Os detalhes importantes aqui mostram o `ScriptName`, o `Line` de código e o `ScriptLineNumber` em que a invocação foi iniciada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="3e72c-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="3e72c-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="3e72c-178">Essa propriedade mostra a ordem das chamadas de função que levaram você ao código no qual a exceção foi gerada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="3e72c-179">Estou fazendo chamadas somente para funções no mesmo script, mas isso acompanharia as chamadas se vários scripts estivessem envolvidos.</span><span class="sxs-lookup"><span data-stu-id="3e72c-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="3e72c-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="3e72c-180">$PSItem.Exception</span></span>

<span data-ttu-id="3e72c-181">Essa é a exceção real que foi gerada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="3e72c-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="3e72c-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="3e72c-183">Essa é a mensagem geral que descreve a exceção e é um bom ponto de partida ao solucionar problemas.</span><span class="sxs-lookup"><span data-stu-id="3e72c-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="3e72c-184">A maioria das exceções tem uma mensagem padrão, mas também pode ser personalizada quando a exceção é gerada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="3e72c-185">Essa também será a mensagem retornada ao chamar `$PSItem.ToString()`, se não houver uma definida em `ErrorRecord`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="3e72c-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="3e72c-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="3e72c-187">Exceções podem conter exceções internas.</span><span class="sxs-lookup"><span data-stu-id="3e72c-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="3e72c-188">Geralmente, esse é o caso quando o código que você está chamando captura uma exceção e gera uma exceção diferente.</span><span class="sxs-lookup"><span data-stu-id="3e72c-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="3e72c-189">A exceção original é colocada dentro da nova exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="3e72c-190">Vou revisitar isso mais tarde quando falar sobre gerar novamente exceções.</span><span class="sxs-lookup"><span data-stu-id="3e72c-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="3e72c-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="3e72c-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="3e72c-192">Este é o `StackTrace` para a exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="3e72c-193">Mostrei um `ScriptStackTrace` acima, mas esse é para as chamadas para o código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="3e72c-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="3e72c-194">Você só obterá esse rastreamento de pilha quando o evento for gerado pelo código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="3e72c-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="3e72c-195">Estou chamando uma função do .NET Framework diretamente para que apenas ela seja exibida neste exemplo.</span><span class="sxs-lookup"><span data-stu-id="3e72c-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="3e72c-196">Geralmente, quando você olha para um rastreamento de pilha, está procurando onde o seu código é interrompido e onde as chamadas do sistema começam.</span><span class="sxs-lookup"><span data-stu-id="3e72c-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="3e72c-197">Trabalhando com exceções</span><span class="sxs-lookup"><span data-stu-id="3e72c-197">Working with exceptions</span></span>

<span data-ttu-id="3e72c-198">Exceções são mais do que apenas a sintaxe básica e as propriedades da exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="3e72c-199">Capturando exceções tipadas</span><span class="sxs-lookup"><span data-stu-id="3e72c-199">Catching typed exceptions</span></span>

<span data-ttu-id="3e72c-200">Você pode ser seletivo com as exceções que você captura.</span><span class="sxs-lookup"><span data-stu-id="3e72c-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="3e72c-201">As exceções têm um tipo e você pode especificar o tipo de exceção que deseja capturar.</span><span class="sxs-lookup"><span data-stu-id="3e72c-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="3e72c-202">O tipo de exceção é verificado para cada bloco `catch` até encontrar um que corresponda à sua exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="3e72c-203">É importante perceber que as exceções podem ser herdadas de outras exceções.</span><span class="sxs-lookup"><span data-stu-id="3e72c-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="3e72c-204">No exemplo acima, `FileNotFoundException` herda de `IOException`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="3e72c-205">Portanto, se o `IOException` foi primeiro, ele seria chamado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="3e72c-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="3e72c-206">Somente um bloco catch será invocado mesmo se houver várias correspondências.</span><span class="sxs-lookup"><span data-stu-id="3e72c-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="3e72c-207">Se tivéssemos um `System.IO.PathTooLongException`, o `IOException` seria correspondente, mas se tivéssemos um `InsufficientMemoryException`, nada o capturaria e ele propagaria a pilha.</span><span class="sxs-lookup"><span data-stu-id="3e72c-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="3e72c-208">Capturar vários tipos de uma vez</span><span class="sxs-lookup"><span data-stu-id="3e72c-208">Catch multiple types at once</span></span>

<span data-ttu-id="3e72c-209">É possível capturar vários tipos de exceção com a mesma instrução `catch`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="3e72c-210">Agradecemos a `/u/Sheppard_Ra` por sugerir essa adição.</span><span class="sxs-lookup"><span data-stu-id="3e72c-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="3e72c-211">Gerando exceções tipadas</span><span class="sxs-lookup"><span data-stu-id="3e72c-211">Throwing typed exceptions</span></span>

<span data-ttu-id="3e72c-212">Você pode gerar exceções tipadas no PowerShell.</span><span class="sxs-lookup"><span data-stu-id="3e72c-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="3e72c-213">Em vez de chamar `throw` com uma cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="3e72c-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="3e72c-214">Use um acelerador de exceção como este:</span><span class="sxs-lookup"><span data-stu-id="3e72c-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="3e72c-215">Mas você precisa especificar uma mensagem ao fazer isso dessa maneira.</span><span class="sxs-lookup"><span data-stu-id="3e72c-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="3e72c-216">Você também pode criar uma nova instância de uma exceção a ser gerada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="3e72c-217">A mensagem é opcional quando você faz isso porque o sistema tem mensagens padrão para todas as exceções internas.</span><span class="sxs-lookup"><span data-stu-id="3e72c-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="3e72c-218">Se você não estiver usando o PowerShell 5.0 ou superior, precisará usar a abordagem de `New-Object` mais antiga.</span><span class="sxs-lookup"><span data-stu-id="3e72c-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="3e72c-219">Usando uma exceção tipada, você (ou outros) podem capturar a exceção pelo tipo, conforme mencionado na seção anterior.</span><span class="sxs-lookup"><span data-stu-id="3e72c-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="3e72c-220">Write-Error -Exception</span><span class="sxs-lookup"><span data-stu-id="3e72c-220">Write-Error -Exception</span></span>

<span data-ttu-id="3e72c-221">Podemos adicionar essas exceções tipadas ao `Write-Error` e ainda podemos realizar `catch` nos erros por tipo de exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="3e72c-222">Use `Write-Error` como nestes exemplos:</span><span class="sxs-lookup"><span data-stu-id="3e72c-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="3e72c-223">Em seguida, podemos capturá-lo da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="3e72c-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="3e72c-224">A grande lista de exceções do .NET</span><span class="sxs-lookup"><span data-stu-id="3e72c-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="3e72c-225">Compilei uma lista mestra com a ajuda da [Comunidade do Reddit/r/PowerShell][], que contém centenas de exceções do .NET para complementar esta postagem.</span><span class="sxs-lookup"><span data-stu-id="3e72c-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="3e72c-226">[A grande lista de exceções do .NET][]</span><span class="sxs-lookup"><span data-stu-id="3e72c-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="3e72c-227">Começo pesquisando a lista de exceções que parecem ser adequadas para a minha situação.</span><span class="sxs-lookup"><span data-stu-id="3e72c-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="3e72c-228">Você deve tentar usar exceções no namespace `System` base.</span><span class="sxs-lookup"><span data-stu-id="3e72c-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="3e72c-229">As exceções são objetos</span><span class="sxs-lookup"><span data-stu-id="3e72c-229">Exceptions are objects</span></span>

<span data-ttu-id="3e72c-230">Se você começar a usar muitas exceções tipadas, lembre-se de que elas são objetos.</span><span class="sxs-lookup"><span data-stu-id="3e72c-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="3e72c-231">Exceções diferentes têm construtores e propriedades diferentes.</span><span class="sxs-lookup"><span data-stu-id="3e72c-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="3e72c-232">Se olharmos a documentação do [FileNotFoundException][] para `System.IO.FileNotFoundException`, veremos que podemos passar uma mensagem e um caminho de arquivo.</span><span class="sxs-lookup"><span data-stu-id="3e72c-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="3e72c-233">E ele tem uma propriedade `FileName` que expõe esse caminho de arquivo.</span><span class="sxs-lookup"><span data-stu-id="3e72c-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="3e72c-234">Você deve consultar a [documentação do .NET][] para saber mais sobre outros construtores e propriedades de objeto.</span><span class="sxs-lookup"><span data-stu-id="3e72c-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="3e72c-235">Como gerar novamente uma exceção</span><span class="sxs-lookup"><span data-stu-id="3e72c-235">Re-throwing an exception</span></span>

<span data-ttu-id="3e72c-236">Se a única coisa que você vai fazer no seu bloco `catch` é realizar `throw` na mesma exceção, não realize `catch` nela.</span><span class="sxs-lookup"><span data-stu-id="3e72c-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="3e72c-237">Você só deve realizar `catch` em uma exceção que planeja manipular ou executar alguma ação quando isso acontecer.</span><span class="sxs-lookup"><span data-stu-id="3e72c-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="3e72c-238">Há ocasiões em que você deseja executar uma ação em uma exceção, mas gera a exceção novamente para que algo em downstream possa lidar com ela.</span><span class="sxs-lookup"><span data-stu-id="3e72c-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="3e72c-239">Podemos gravar uma mensagem ou registrar o problema perto de onde o descobrimos e lidar com o problema mais adiante na pilha.</span><span class="sxs-lookup"><span data-stu-id="3e72c-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="3e72c-240">Curiosamente, podemos chamar `throw` de dentro do `catch` e ele gera novamente a exceção atual.</span><span class="sxs-lookup"><span data-stu-id="3e72c-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="3e72c-241">Queremos gerar novamente a exceção para preservar as informações de execução originais, como o script de origem e o número de linha.</span><span class="sxs-lookup"><span data-stu-id="3e72c-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="3e72c-242">Se gerarmos uma nova exceção nesse momento, ela ocultará onde a exceção foi iniciada.</span><span class="sxs-lookup"><span data-stu-id="3e72c-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="3e72c-243">Como gerar novamente uma nova exceção</span><span class="sxs-lookup"><span data-stu-id="3e72c-243">Re-throwing a new exception</span></span>

<span data-ttu-id="3e72c-244">Se você capturar uma exceção, mas desejar gerar uma diferente, deverá aninhar a exceção original dentro da nova.</span><span class="sxs-lookup"><span data-stu-id="3e72c-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="3e72c-245">Isso permite que alguém abaixo na pilha acesse-a como o `$PSItem.Exception.InnerException`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="3e72c-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="3e72c-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="3e72c-247">O que eu não gosto sobre usar `throw` para exceções brutas é que a mensagem de erro aponta para a instrução `throw` e indica que aquela linha é onde o problema está.</span><span class="sxs-lookup"><span data-stu-id="3e72c-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="3e72c-248">Uma mensagem de erro que informa que o meu script foi interrompido porque chamei `throw` na linha 31 é uma mensagem incorreta para ser exibida aos usuários do seu script.</span><span class="sxs-lookup"><span data-stu-id="3e72c-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="3e72c-249">Ela não informa nada de útil.</span><span class="sxs-lookup"><span data-stu-id="3e72c-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="3e72c-250">Dexter Dhami apontou que posso usar `ThrowTerminatingError()` para corrigir isso.</span><span class="sxs-lookup"><span data-stu-id="3e72c-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="3e72c-251">Se presumirmos que `ThrowTerminatingError()` foi chamado dentro de uma função `Get-Resource`, esse será o erro que veremos.</span><span class="sxs-lookup"><span data-stu-id="3e72c-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="3e72c-252">Você percebe como ele aponta para a função `Get-Resource` como a origem do problema?</span><span class="sxs-lookup"><span data-stu-id="3e72c-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="3e72c-253">Isso informa ao usuário algo útil.</span><span class="sxs-lookup"><span data-stu-id="3e72c-253">That tells the user something useful.</span></span>

<span data-ttu-id="3e72c-254">Como `$PSItem` é um `ErrorRecord`, também podemos usar `ThrowTerminatingError` dessa maneira para gerar novamente.</span><span class="sxs-lookup"><span data-stu-id="3e72c-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="3e72c-255">Isso altera a origem do erro para o cmdlet e oculta os elementos internos da sua função dos usuários do seu cmdlet.</span><span class="sxs-lookup"><span data-stu-id="3e72c-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="3e72c-256">Try pode criar erros de encerramento</span><span class="sxs-lookup"><span data-stu-id="3e72c-256">Try can create terminating errors</span></span>

<span data-ttu-id="3e72c-257">Kirk Munro destaca que algumas exceções estão encerrando erros apenas quando são executadas dentro de um bloco `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="3e72c-258">A seguir está o exemplo que ele me deu que gera uma exceção de runtime de divisão por zero.</span><span class="sxs-lookup"><span data-stu-id="3e72c-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="3e72c-259">Em seguida, invoque-a dessa forma para que ela gere o erro e ainda gere a mensagem.</span><span class="sxs-lookup"><span data-stu-id="3e72c-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="3e72c-260">Mas, ao colocar o mesmo código dentro de um `try/catch`, vemos outra coisa ocorrer.</span><span class="sxs-lookup"><span data-stu-id="3e72c-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="3e72c-261">Vemos que o erro se torna um erro de encerramento e não gera a primeira mensagem.</span><span class="sxs-lookup"><span data-stu-id="3e72c-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="3e72c-262">O que eu não gosto sobre isso é que você pode ter um código em uma função e ele funcionar de modo diferente se alguém estiver usando um `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="3e72c-263">Ainda não tive problemas com isso, mas é um caso excepcional a saber.</span><span class="sxs-lookup"><span data-stu-id="3e72c-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="3e72c-264">$PSCmdlet.ThrowTerminatingError() dentro de try/catch</span><span class="sxs-lookup"><span data-stu-id="3e72c-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="3e72c-265">Uma nuance de `$PSCmdlet.ThrowTerminatingError()` é que ele cria um erro de encerramento dentro do seu cmdlet, mas se transforma em um erro de não encerramento após sair do cmdlet.</span><span class="sxs-lookup"><span data-stu-id="3e72c-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="3e72c-266">Isso deixa a responsabilidade de decidir como tratar o erro com o chamador da sua função.</span><span class="sxs-lookup"><span data-stu-id="3e72c-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="3e72c-267">Eles podem transformá-lo novamente em um erro de encerramento usando `-ErrorAction Stop` ou chamando-o de dentro de um `try{...}catch{...}`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="3e72c-268">Modelos de função pública</span><span class="sxs-lookup"><span data-stu-id="3e72c-268">Public function templates</span></span>

<span data-ttu-id="3e72c-269">Uma última consideração sobre a minha conversa com Kirk Munro é que ele coloca um `try{...}catch{...}` em todos os blocos `begin`, `process` e `end` em todas as funções avançadas dele.</span><span class="sxs-lookup"><span data-stu-id="3e72c-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="3e72c-270">Nesses blocos catch genéricos, uma única linha usa `$PSCmdlet.ThrowTerminatingError($PSItem)` para lidar com todas as exceções que estão saindo das funções.</span><span class="sxs-lookup"><span data-stu-id="3e72c-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="3e72c-271">Como tudo está em uma instrução `try` nas funções dele, tudo funciona consistentemente.</span><span class="sxs-lookup"><span data-stu-id="3e72c-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="3e72c-272">Isso também exibe erros de limpeza para o usuário final que oculta o código interno do erro gerado.</span><span class="sxs-lookup"><span data-stu-id="3e72c-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="3e72c-273">Trap</span><span class="sxs-lookup"><span data-stu-id="3e72c-273">Trap</span></span>

<span data-ttu-id="3e72c-274">Eu me concentrei no aspecto `try/catch` das exceções.</span><span class="sxs-lookup"><span data-stu-id="3e72c-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="3e72c-275">Mas há um recurso herdado que preciso mencionar antes de terminarmos.</span><span class="sxs-lookup"><span data-stu-id="3e72c-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="3e72c-276">Um `trap` é colocado em um script ou função para capturar todas as exceções que acontecem nesse escopo.</span><span class="sxs-lookup"><span data-stu-id="3e72c-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="3e72c-277">Quando ocorre uma exceção, o código no `trap` é executado e o código normal continua.</span><span class="sxs-lookup"><span data-stu-id="3e72c-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="3e72c-278">Se ocorrerem várias exceções, o trap será chamado repetidamente.</span><span class="sxs-lookup"><span data-stu-id="3e72c-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="3e72c-279">Pessoalmente, nunca adotei essa abordagem, mas entendo como ela pode ser valiosa em scripts de administrador ou de controlador que registram todas as exceções e, em seguida, continuam a executar.</span><span class="sxs-lookup"><span data-stu-id="3e72c-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="3e72c-280">Últimas considerações</span><span class="sxs-lookup"><span data-stu-id="3e72c-280">Closing remarks</span></span>

<span data-ttu-id="3e72c-281">Adicionar uma manipulação de exceção adequada aos seus scripts não só os torna mais estáveis, mas também facilita a solução de problemas dessas exceções.</span><span class="sxs-lookup"><span data-stu-id="3e72c-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="3e72c-282">Passei muito tempo falando sobre `throw` porque é um conceito fundamental ao falar sobre a manipulação de exceção.</span><span class="sxs-lookup"><span data-stu-id="3e72c-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="3e72c-283">O PowerShell também nos forneceu `Write-Error`, que lida com todas as situações em que você usaria `throw`.</span><span class="sxs-lookup"><span data-stu-id="3e72c-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="3e72c-284">Portanto, não ache que você precisa usar `throw` depois de ler isso.</span><span class="sxs-lookup"><span data-stu-id="3e72c-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="3e72c-285">Agora que já escrevi sobre como manipular exceções nesse detalhe, vou passar a usar `Write-Error -Stop` para gerar erros no meu código.</span><span class="sxs-lookup"><span data-stu-id="3e72c-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="3e72c-286">Também vou usar o conselho do Kirk e tornar o `ThrowTerminatingError` o meu manipulador de exceção padrão para cada função.</span><span class="sxs-lookup"><span data-stu-id="3e72c-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[versão original]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Comunidade do Reddit/r/PowerShell]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[A grande lista de exceções do .NET]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[Documentação do .NET]: /dotnet/api
[.NET documentation]: /dotnet/api
